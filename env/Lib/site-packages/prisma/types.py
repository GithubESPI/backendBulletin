# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    name: Optional[_str]
    emailVerified: Optional[datetime.datetime]
    image: Optional[_str]
    accounts: 'AccountCreateManyNestedWithoutRelationsInput'
    sessions: 'SessionCreateManyNestedWithoutRelationsInput'
    Authenticator: 'AuthenticatorCreateManyNestedWithoutRelationsInput'
    configurations: 'ConfigurationCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    name: Optional[_str]
    emailVerified: Optional[datetime.datetime]
    image: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str


class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]


_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: Optional[_str]
    email: _str
    emailVerified: Optional[datetime.datetime]
    image: Optional[_str]
    accounts: 'AccountUpdateManyWithoutRelationsInput'
    sessions: 'SessionUpdateManyWithoutRelationsInput'
    Authenticator: 'AuthenticatorUpdateManyWithoutRelationsInput'
    configurations: 'ConfigurationUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: Optional[_str]
    email: _str
    emailVerified: Optional[datetime.datetime]
    image: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_emailVerified_OrderByInput = TypedDict(
    '_User_emailVerified_OrderByInput',
    {
        'emailVerified': 'SortOrder',
    },
    total=True
)

_User_image_OrderByInput = TypedDict(
    '_User_image_OrderByInput',
    {
        'image': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_name_OrderByInput',
    '_User_email_OrderByInput',
    '_User_emailVerified_OrderByInput',
    '_User_image_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    accounts: Union[bool, 'FindManyAccountArgsFromUser']
    sessions: Union[bool, 'FindManySessionArgsFromUser']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromUser']
    configurations: Union[bool, 'FindManyConfigurationArgsFromUser']


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    accounts: Union[bool, 'FindManyAccountArgsFromUser']
    sessions: Union[bool, 'FindManySessionArgsFromUser']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromUser']
    configurations: Union[bool, 'FindManyConfigurationArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class AccountArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class SessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class VerificationTokenArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class AuthenticatorArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class ConfigurationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    emailVerified: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    accounts: 'AccountListRelationFilter'
    sessions: 'SessionListRelationFilter'
    Authenticator: 'AuthenticatorListRelationFilter'
    configurations: 'ConfigurationListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    emailVerified: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    email: _str
    emailVerified: datetime.datetime
    image: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    name: _str
    email: _str
    emailVerified: datetime.datetime
    image: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    emailVerified: bool
    image: bool
    createdAt: bool
    updatedAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    emailVerified: bool
    image: bool
    createdAt: bool
    updatedAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'emailVerified': bool,
        'image': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'emailVerified': int,
        'image': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'name',
    'email',
    'emailVerified',
    'image',
    'accounts',
    'sessions',
    'Authenticator',
    'configurations',
    'createdAt',
    'updatedAt',
]
UserScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'emailVerified',
    'image',
    'createdAt',
    'updatedAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'accounts',
        'sessions',
        'Authenticator',
        'configurations',
    ]

# Account types

class AccountOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Account create method"""
    userId: _str
    refresh_token: Optional[_str]
    access_token: Optional[_str]
    expires_at: Optional[_int]
    token_type: Optional[_str]
    scope: Optional[_str]
    id_token: Optional[_str]
    session_state: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'


class AccountCreateInput(AccountOptionalCreateInput):
    """Required arguments to the Account create method"""
    type: _str
    provider: _str
    providerAccountId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AccountOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Account create method, without relations"""
    userId: _str
    refresh_token: Optional[_str]
    access_token: Optional[_str]
    expires_at: Optional[_int]
    token_type: Optional[_str]
    scope: Optional[_str]
    id_token: Optional[_str]
    session_state: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountCreateWithoutRelationsInput(AccountOptionalCreateWithoutRelationsInput):
    """Required arguments to the Account create method, without relations"""
    type: _str
    provider: _str
    providerAccountId: _str


class AccountCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountCreateWithoutRelationsInput'
    connect: 'AccountWhereUniqueInput'


class AccountCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AccountCreateWithoutRelationsInput', List['AccountCreateWithoutRelationsInput']]
    connect: Union['AccountWhereUniqueInput', List['AccountWhereUniqueInput']]


_AccountCompoundPrimaryKeyInner = TypedDict(
    '_AccountCompoundPrimaryKeyInner',
    {
        'provider': '_str',
        'providerAccountId': '_str',
    },
    total=True
)

_AccountCompoundPrimaryKey = TypedDict(
    '_AccountCompoundPrimaryKey',
    {
        'provider_providerAccountId': '_AccountCompoundPrimaryKeyInner',
    },
    total=True
)

AccountWhereUniqueInput = _AccountCompoundPrimaryKey


class AccountUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    type: _str
    provider: _str
    providerAccountId: _str
    refresh_token: Optional[_str]
    access_token: Optional[_str]
    expires_at: Optional[Union[AtomicIntInput, _int]]
    token_type: Optional[_str]
    scope: Optional[_str]
    id_token: Optional[_str]
    session_state: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class AccountUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    type: _str
    provider: _str
    providerAccountId: _str
    refresh_token: Optional[_str]
    access_token: Optional[_str]
    expires_at: Optional[Union[AtomicIntInput, _int]]
    token_type: Optional[_str]
    scope: Optional[_str]
    id_token: Optional[_str]
    session_state: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AccountCreateWithoutRelationsInput']
    connect: List['AccountWhereUniqueInput']
    set: List['AccountWhereUniqueInput']
    disconnect: List['AccountWhereUniqueInput']
    delete: List['AccountWhereUniqueInput']

    # TODO
    # update: List['AccountUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AccountUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AccountScalarWhereInput']
    # upsert: List['AccountUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['AccountCreateOrConnectWithoutRelationsInput']


class AccountUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountCreateWithoutRelationsInput'
    connect: 'AccountWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AccountUpdateInput'
    # upsert: 'AccountUpsertWithoutRelationsInput'
    # connectOrCreate: 'AccountCreateOrConnectWithoutRelationsInput'


class AccountUpsertInput(TypedDict):
    create: 'AccountCreateInput'
    update: 'AccountUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Account_userId_OrderByInput = TypedDict(
    '_Account_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Account_type_OrderByInput = TypedDict(
    '_Account_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Account_provider_OrderByInput = TypedDict(
    '_Account_provider_OrderByInput',
    {
        'provider': 'SortOrder',
    },
    total=True
)

_Account_providerAccountId_OrderByInput = TypedDict(
    '_Account_providerAccountId_OrderByInput',
    {
        'providerAccountId': 'SortOrder',
    },
    total=True
)

_Account_refresh_token_OrderByInput = TypedDict(
    '_Account_refresh_token_OrderByInput',
    {
        'refresh_token': 'SortOrder',
    },
    total=True
)

_Account_access_token_OrderByInput = TypedDict(
    '_Account_access_token_OrderByInput',
    {
        'access_token': 'SortOrder',
    },
    total=True
)

_Account_expires_at_OrderByInput = TypedDict(
    '_Account_expires_at_OrderByInput',
    {
        'expires_at': 'SortOrder',
    },
    total=True
)

_Account_token_type_OrderByInput = TypedDict(
    '_Account_token_type_OrderByInput',
    {
        'token_type': 'SortOrder',
    },
    total=True
)

_Account_scope_OrderByInput = TypedDict(
    '_Account_scope_OrderByInput',
    {
        'scope': 'SortOrder',
    },
    total=True
)

_Account_id_token_OrderByInput = TypedDict(
    '_Account_id_token_OrderByInput',
    {
        'id_token': 'SortOrder',
    },
    total=True
)

_Account_session_state_OrderByInput = TypedDict(
    '_Account_session_state_OrderByInput',
    {
        'session_state': 'SortOrder',
    },
    total=True
)

_Account_createdAt_OrderByInput = TypedDict(
    '_Account_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Account_updatedAt_OrderByInput = TypedDict(
    '_Account_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

AccountOrderByInput = Union[
    '_Account_userId_OrderByInput',
    '_Account_type_OrderByInput',
    '_Account_provider_OrderByInput',
    '_Account_providerAccountId_OrderByInput',
    '_Account_refresh_token_OrderByInput',
    '_Account_access_token_OrderByInput',
    '_Account_expires_at_OrderByInput',
    '_Account_token_type_OrderByInput',
    '_Account_scope_OrderByInput',
    '_Account_id_token_OrderByInput',
    '_Account_session_state_OrderByInput',
    '_Account_createdAt_OrderByInput',
    '_Account_updatedAt_OrderByInput',
]



# recursive Account types
# TODO: cleanup these types



AccountRelationFilter = TypedDict(
    'AccountRelationFilter',
    {
        'is': 'AccountWhereInput',
        'is_not': 'AccountWhereInput',
    },
    total=False,
)


class AccountListRelationFilter(TypedDict, total=False):
    some: 'AccountWhereInput'
    none: 'AccountWhereInput'
    every: 'AccountWhereInput'


class AccountInclude(TypedDict, total=False):
    """Account relational arguments"""
    user: Union[bool, 'UserArgsFromAccount']


class UserIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    accounts: Union[bool, 'FindManyAccountArgsFromAccount']
    sessions: Union[bool, 'FindManySessionArgsFromAccount']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromAccount']
    configurations: Union[bool, 'FindManyConfigurationArgsFromAccount']


class UserArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class AccountArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class SessionArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""


class VerificationTokenArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class AuthenticatorArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class ConfigurationArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManyAccountArgs = FindManyAccountArgsFromAccount
FindFirstAccountArgs = FindManyAccountArgsFromAccount


class AccountWhereInput(TypedDict, total=False):
    """Account arguments for searching"""
    userId: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    provider: Union[_str, 'types.StringFilter']
    providerAccountId: Union[_str, 'types.StringFilter']
    refresh_token: Union[None, _str, 'types.StringFilter']
    access_token: Union[None, _str, 'types.StringFilter']
    expires_at: Union[None, _int, 'types.IntFilter']
    token_type: Union[None, _str, 'types.StringFilter']
    scope: Union[None, _str, 'types.StringFilter']
    id_token: Union[None, _str, 'types.StringFilter']
    session_state: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['AccountWhereInput', List['AccountWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AccountWhereInput']
    OR: List['AccountWhereInput']
    NOT: List['AccountWhereInput']



# aggregate Account types


class AccountScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Account arguments for searching"""
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    provider: Union[_str, 'types.StringWithAggregatesFilter']
    providerAccountId: Union[_str, 'types.StringWithAggregatesFilter']
    refresh_token: Union[_str, 'types.StringWithAggregatesFilter']
    access_token: Union[_str, 'types.StringWithAggregatesFilter']
    expires_at: Union[_int, 'types.IntWithAggregatesFilter']
    token_type: Union[_str, 'types.StringWithAggregatesFilter']
    scope: Union[_str, 'types.StringWithAggregatesFilter']
    id_token: Union[_str, 'types.StringWithAggregatesFilter']
    session_state: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AccountScalarWhereWithAggregatesInput']
    OR: List['AccountScalarWhereWithAggregatesInput']
    NOT: List['AccountScalarWhereWithAggregatesInput']



class AccountGroupByOutput(TypedDict, total=False):
    userId: _str
    type: _str
    provider: _str
    providerAccountId: _str
    refresh_token: _str
    access_token: _str
    expires_at: _int
    token_type: _str
    scope: _str
    id_token: _str
    session_state: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AccountSumAggregateOutput'
    _avg: 'AccountAvgAggregateOutput'
    _min: 'AccountMinAggregateOutput'
    _max: 'AccountMaxAggregateOutput'
    _count: 'AccountCountAggregateOutput'


class AccountAvgAggregateOutput(TypedDict, total=False):
    """Account output for aggregating averages"""
    expires_at: float


class AccountSumAggregateOutput(TypedDict, total=False):
    """Account output for aggregating sums"""
    expires_at: _int


class AccountScalarAggregateOutput(TypedDict, total=False):
    """Account output including scalar fields"""
    userId: _str
    type: _str
    provider: _str
    providerAccountId: _str
    refresh_token: _str
    access_token: _str
    expires_at: _int
    token_type: _str
    scope: _str
    id_token: _str
    session_state: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AccountMinAggregateOutput = AccountScalarAggregateOutput
AccountMaxAggregateOutput = AccountScalarAggregateOutput


class AccountMaxAggregateInput(TypedDict, total=False):
    """Account input for aggregating by max"""
    userId: bool
    type: bool
    provider: bool
    providerAccountId: bool
    refresh_token: bool
    access_token: bool
    expires_at: bool
    token_type: bool
    scope: bool
    id_token: bool
    session_state: bool
    createdAt: bool
    updatedAt: bool


class AccountMinAggregateInput(TypedDict, total=False):
    """Account input for aggregating by min"""
    userId: bool
    type: bool
    provider: bool
    providerAccountId: bool
    refresh_token: bool
    access_token: bool
    expires_at: bool
    token_type: bool
    scope: bool
    id_token: bool
    session_state: bool
    createdAt: bool
    updatedAt: bool


class AccountNumberAggregateInput(TypedDict, total=False):
    """Account input for aggregating numbers"""
    expires_at: bool


AccountAvgAggregateInput = AccountNumberAggregateInput
AccountSumAggregateInput = AccountNumberAggregateInput


AccountCountAggregateInput = TypedDict(
    'AccountCountAggregateInput',
    {
        'userId': bool,
        'type': bool,
        'provider': bool,
        'providerAccountId': bool,
        'refresh_token': bool,
        'access_token': bool,
        'expires_at': bool,
        'token_type': bool,
        'scope': bool,
        'id_token': bool,
        'session_state': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AccountCountAggregateOutput = TypedDict(
    'AccountCountAggregateOutput',
    {
        'userId': int,
        'type': int,
        'provider': int,
        'providerAccountId': int,
        'refresh_token': int,
        'access_token': int,
        'expires_at': int,
        'token_type': int,
        'scope': int,
        'id_token': int,
        'session_state': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AccountKeys = Literal[
    'userId',
    'type',
    'provider',
    'providerAccountId',
    'refresh_token',
    'access_token',
    'expires_at',
    'token_type',
    'scope',
    'id_token',
    'session_state',
    'createdAt',
    'updatedAt',
    'user',
]
AccountScalarFieldKeys = Literal[
    'userId',
    'type',
    'provider',
    'providerAccountId',
    'refresh_token',
    'access_token',
    'expires_at',
    'token_type',
    'scope',
    'id_token',
    'session_state',
    'createdAt',
    'updatedAt',
]
AccountScalarFieldKeysT = TypeVar('AccountScalarFieldKeysT', bound=AccountScalarFieldKeys)

AccountRelationalFieldKeys = Literal[
        'user',
    ]

# Session types

class SessionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Session create method"""
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SessionCreateInput(SessionOptionalCreateInput):
    """Required arguments to the Session create method"""
    sessionToken: _str
    expires: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SessionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Session create method, without relations"""
    userId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SessionCreateWithoutRelationsInput(SessionOptionalCreateWithoutRelationsInput):
    """Required arguments to the Session create method, without relations"""
    sessionToken: _str
    expires: datetime.datetime


class SessionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SessionCreateWithoutRelationsInput'
    connect: 'SessionWhereUniqueInput'


class SessionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SessionCreateWithoutRelationsInput', List['SessionCreateWithoutRelationsInput']]
    connect: Union['SessionWhereUniqueInput', List['SessionWhereUniqueInput']]


_SessionWhereUnique_sessionToken_Input = TypedDict(
    '_SessionWhereUnique_sessionToken_Input',
    {
        'sessionToken': '_str',
    },
    total=True
)

SessionWhereUniqueInput = _SessionWhereUnique_sessionToken_Input


class SessionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    sessionToken: _str
    expires: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SessionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    sessionToken: _str
    expires: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SessionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SessionCreateWithoutRelationsInput']
    connect: List['SessionWhereUniqueInput']
    set: List['SessionWhereUniqueInput']
    disconnect: List['SessionWhereUniqueInput']
    delete: List['SessionWhereUniqueInput']

    # TODO
    # update: List['SessionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SessionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SessionScalarWhereInput']
    # upsert: List['SessionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SessionCreateOrConnectWithoutRelationsInput']


class SessionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SessionCreateWithoutRelationsInput'
    connect: 'SessionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SessionUpdateInput'
    # upsert: 'SessionUpsertWithoutRelationsInput'
    # connectOrCreate: 'SessionCreateOrConnectWithoutRelationsInput'


class SessionUpsertInput(TypedDict):
    create: 'SessionCreateInput'
    update: 'SessionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Session_sessionToken_OrderByInput = TypedDict(
    '_Session_sessionToken_OrderByInput',
    {
        'sessionToken': 'SortOrder',
    },
    total=True
)

_Session_userId_OrderByInput = TypedDict(
    '_Session_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Session_expires_OrderByInput = TypedDict(
    '_Session_expires_OrderByInput',
    {
        'expires': 'SortOrder',
    },
    total=True
)

_Session_createdAt_OrderByInput = TypedDict(
    '_Session_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Session_updatedAt_OrderByInput = TypedDict(
    '_Session_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

SessionOrderByInput = Union[
    '_Session_sessionToken_OrderByInput',
    '_Session_userId_OrderByInput',
    '_Session_expires_OrderByInput',
    '_Session_createdAt_OrderByInput',
    '_Session_updatedAt_OrderByInput',
]



# recursive Session types
# TODO: cleanup these types



SessionRelationFilter = TypedDict(
    'SessionRelationFilter',
    {
        'is': 'SessionWhereInput',
        'is_not': 'SessionWhereInput',
    },
    total=False,
)


class SessionListRelationFilter(TypedDict, total=False):
    some: 'SessionWhereInput'
    none: 'SessionWhereInput'
    every: 'SessionWhereInput'


class SessionInclude(TypedDict, total=False):
    """Session relational arguments"""
    user: Union[bool, 'UserArgsFromSession']


class UserIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""
    accounts: Union[bool, 'FindManyAccountArgsFromSession']
    sessions: Union[bool, 'FindManySessionArgsFromSession']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromSession']
    configurations: Union[bool, 'FindManyConfigurationArgsFromSession']


class UserArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""
    user: Union[bool, 'UserArgsFromSession']


class AccountArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""
    user: Union[bool, 'UserArgsFromSession']


class SessionArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""


class VerificationTokenArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""
    user: Union[bool, 'UserArgsFromSession']


class AuthenticatorArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromSession(TypedDict, total=False):
    """Relational arguments for Session"""
    user: Union[bool, 'UserArgsFromSession']


class ConfigurationArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromSession(TypedDict, total=False):
    """Arguments for Session"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManySessionArgs = FindManySessionArgsFromSession
FindFirstSessionArgs = FindManySessionArgsFromSession


class SessionWhereInput(TypedDict, total=False):
    """Session arguments for searching"""
    sessionToken: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    expires: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SessionWhereInput', List['SessionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SessionWhereInput']
    OR: List['SessionWhereInput']
    NOT: List['SessionWhereInput']



# aggregate Session types


class SessionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Session arguments for searching"""
    sessionToken: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    expires: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SessionScalarWhereWithAggregatesInput']
    OR: List['SessionScalarWhereWithAggregatesInput']
    NOT: List['SessionScalarWhereWithAggregatesInput']



class SessionGroupByOutput(TypedDict, total=False):
    sessionToken: _str
    userId: _str
    expires: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'SessionSumAggregateOutput'
    _avg: 'SessionAvgAggregateOutput'
    _min: 'SessionMinAggregateOutput'
    _max: 'SessionMaxAggregateOutput'
    _count: 'SessionCountAggregateOutput'


class SessionAvgAggregateOutput(TypedDict, total=False):
    """Session output for aggregating averages"""


class SessionSumAggregateOutput(TypedDict, total=False):
    """Session output for aggregating sums"""


class SessionScalarAggregateOutput(TypedDict, total=False):
    """Session output including scalar fields"""
    sessionToken: _str
    userId: _str
    expires: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


SessionMinAggregateOutput = SessionScalarAggregateOutput
SessionMaxAggregateOutput = SessionScalarAggregateOutput


class SessionMaxAggregateInput(TypedDict, total=False):
    """Session input for aggregating by max"""
    sessionToken: bool
    userId: bool
    expires: bool
    createdAt: bool
    updatedAt: bool


class SessionMinAggregateInput(TypedDict, total=False):
    """Session input for aggregating by min"""
    sessionToken: bool
    userId: bool
    expires: bool
    createdAt: bool
    updatedAt: bool


class SessionNumberAggregateInput(TypedDict, total=False):
    """Session input for aggregating numbers"""


SessionAvgAggregateInput = SessionNumberAggregateInput
SessionSumAggregateInput = SessionNumberAggregateInput


SessionCountAggregateInput = TypedDict(
    'SessionCountAggregateInput',
    {
        'sessionToken': bool,
        'userId': bool,
        'expires': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

SessionCountAggregateOutput = TypedDict(
    'SessionCountAggregateOutput',
    {
        'sessionToken': int,
        'userId': int,
        'expires': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


SessionKeys = Literal[
    'sessionToken',
    'userId',
    'expires',
    'user',
    'createdAt',
    'updatedAt',
]
SessionScalarFieldKeys = Literal[
    'sessionToken',
    'userId',
    'expires',
    'createdAt',
    'updatedAt',
]
SessionScalarFieldKeysT = TypeVar('SessionScalarFieldKeysT', bound=SessionScalarFieldKeys)

SessionRelationalFieldKeys = Literal[
        'user',
    ]

# VerificationToken types

class VerificationTokenOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the VerificationToken create method"""


class VerificationTokenCreateInput(VerificationTokenOptionalCreateInput):
    """Required arguments to the VerificationToken create method"""
    identifier: _str
    token: _str
    expires: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class VerificationTokenOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the VerificationToken create method, without relations"""


class VerificationTokenCreateWithoutRelationsInput(VerificationTokenOptionalCreateWithoutRelationsInput):
    """Required arguments to the VerificationToken create method, without relations"""
    identifier: _str
    token: _str
    expires: datetime.datetime


class VerificationTokenCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'VerificationTokenCreateWithoutRelationsInput'
    connect: 'VerificationTokenWhereUniqueInput'


class VerificationTokenCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['VerificationTokenCreateWithoutRelationsInput', List['VerificationTokenCreateWithoutRelationsInput']]
    connect: Union['VerificationTokenWhereUniqueInput', List['VerificationTokenWhereUniqueInput']]


_VerificationTokenCompoundPrimaryKeyInner = TypedDict(
    '_VerificationTokenCompoundPrimaryKeyInner',
    {
        'identifier': '_str',
        'token': '_str',
    },
    total=True
)

_VerificationTokenCompoundPrimaryKey = TypedDict(
    '_VerificationTokenCompoundPrimaryKey',
    {
        'identifier_token': '_VerificationTokenCompoundPrimaryKeyInner',
    },
    total=True
)

VerificationTokenWhereUniqueInput = _VerificationTokenCompoundPrimaryKey


class VerificationTokenUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    identifier: _str
    token: _str
    expires: datetime.datetime


class VerificationTokenUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    identifier: _str
    token: _str
    expires: datetime.datetime


class VerificationTokenUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['VerificationTokenCreateWithoutRelationsInput']
    connect: List['VerificationTokenWhereUniqueInput']
    set: List['VerificationTokenWhereUniqueInput']
    disconnect: List['VerificationTokenWhereUniqueInput']
    delete: List['VerificationTokenWhereUniqueInput']

    # TODO
    # update: List['VerificationTokenUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['VerificationTokenUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['VerificationTokenScalarWhereInput']
    # upsert: List['VerificationTokenUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['VerificationTokenCreateOrConnectWithoutRelationsInput']


class VerificationTokenUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'VerificationTokenCreateWithoutRelationsInput'
    connect: 'VerificationTokenWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'VerificationTokenUpdateInput'
    # upsert: 'VerificationTokenUpsertWithoutRelationsInput'
    # connectOrCreate: 'VerificationTokenCreateOrConnectWithoutRelationsInput'


class VerificationTokenUpsertInput(TypedDict):
    create: 'VerificationTokenCreateInput'
    update: 'VerificationTokenUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_VerificationToken_identifier_OrderByInput = TypedDict(
    '_VerificationToken_identifier_OrderByInput',
    {
        'identifier': 'SortOrder',
    },
    total=True
)

_VerificationToken_token_OrderByInput = TypedDict(
    '_VerificationToken_token_OrderByInput',
    {
        'token': 'SortOrder',
    },
    total=True
)

_VerificationToken_expires_OrderByInput = TypedDict(
    '_VerificationToken_expires_OrderByInput',
    {
        'expires': 'SortOrder',
    },
    total=True
)

VerificationTokenOrderByInput = Union[
    '_VerificationToken_identifier_OrderByInput',
    '_VerificationToken_token_OrderByInput',
    '_VerificationToken_expires_OrderByInput',
]



# recursive VerificationToken types
# TODO: cleanup these types



VerificationTokenRelationFilter = TypedDict(
    'VerificationTokenRelationFilter',
    {
        'is': 'VerificationTokenWhereInput',
        'is_not': 'VerificationTokenWhereInput',
    },
    total=False,
)


class VerificationTokenListRelationFilter(TypedDict, total=False):
    some: 'VerificationTokenWhereInput'
    none: 'VerificationTokenWhereInput'
    every: 'VerificationTokenWhereInput'


class VerificationTokenInclude(TypedDict, total=False):
    """VerificationToken relational arguments"""


class UserIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""
    accounts: Union[bool, 'FindManyAccountArgsFromVerificationToken']
    sessions: Union[bool, 'FindManySessionArgsFromVerificationToken']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromVerificationToken']
    configurations: Union[bool, 'FindManyConfigurationArgsFromVerificationToken']


class UserArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""
    user: Union[bool, 'UserArgsFromVerificationToken']


class AccountArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""
    user: Union[bool, 'UserArgsFromVerificationToken']


class SessionArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""


class VerificationTokenArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""
    user: Union[bool, 'UserArgsFromVerificationToken']


class AuthenticatorArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromVerificationToken(TypedDict, total=False):
    """Relational arguments for VerificationToken"""
    user: Union[bool, 'UserArgsFromVerificationToken']


class ConfigurationArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromVerificationToken(TypedDict, total=False):
    """Arguments for VerificationToken"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManyVerificationTokenArgs = FindManyVerificationTokenArgsFromVerificationToken
FindFirstVerificationTokenArgs = FindManyVerificationTokenArgsFromVerificationToken


class VerificationTokenWhereInput(TypedDict, total=False):
    """VerificationToken arguments for searching"""
    identifier: Union[_str, 'types.StringFilter']
    token: Union[_str, 'types.StringFilter']
    expires: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['VerificationTokenWhereInput', List['VerificationTokenWhereInput']]
    # but this causes mypy to hang :/
    AND: List['VerificationTokenWhereInput']
    OR: List['VerificationTokenWhereInput']
    NOT: List['VerificationTokenWhereInput']



# aggregate VerificationToken types


class VerificationTokenScalarWhereWithAggregatesInput(TypedDict, total=False):
    """VerificationToken arguments for searching"""
    identifier: Union[_str, 'types.StringWithAggregatesFilter']
    token: Union[_str, 'types.StringWithAggregatesFilter']
    expires: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['VerificationTokenScalarWhereWithAggregatesInput']
    OR: List['VerificationTokenScalarWhereWithAggregatesInput']
    NOT: List['VerificationTokenScalarWhereWithAggregatesInput']



class VerificationTokenGroupByOutput(TypedDict, total=False):
    identifier: _str
    token: _str
    expires: datetime.datetime
    _sum: 'VerificationTokenSumAggregateOutput'
    _avg: 'VerificationTokenAvgAggregateOutput'
    _min: 'VerificationTokenMinAggregateOutput'
    _max: 'VerificationTokenMaxAggregateOutput'
    _count: 'VerificationTokenCountAggregateOutput'


class VerificationTokenAvgAggregateOutput(TypedDict, total=False):
    """VerificationToken output for aggregating averages"""


class VerificationTokenSumAggregateOutput(TypedDict, total=False):
    """VerificationToken output for aggregating sums"""


class VerificationTokenScalarAggregateOutput(TypedDict, total=False):
    """VerificationToken output including scalar fields"""
    identifier: _str
    token: _str
    expires: datetime.datetime


VerificationTokenMinAggregateOutput = VerificationTokenScalarAggregateOutput
VerificationTokenMaxAggregateOutput = VerificationTokenScalarAggregateOutput


class VerificationTokenMaxAggregateInput(TypedDict, total=False):
    """VerificationToken input for aggregating by max"""
    identifier: bool
    token: bool
    expires: bool


class VerificationTokenMinAggregateInput(TypedDict, total=False):
    """VerificationToken input for aggregating by min"""
    identifier: bool
    token: bool
    expires: bool


class VerificationTokenNumberAggregateInput(TypedDict, total=False):
    """VerificationToken input for aggregating numbers"""


VerificationTokenAvgAggregateInput = VerificationTokenNumberAggregateInput
VerificationTokenSumAggregateInput = VerificationTokenNumberAggregateInput


VerificationTokenCountAggregateInput = TypedDict(
    'VerificationTokenCountAggregateInput',
    {
        'identifier': bool,
        'token': bool,
        'expires': bool,
        '_all': bool,
    },
    total=False,
)

VerificationTokenCountAggregateOutput = TypedDict(
    'VerificationTokenCountAggregateOutput',
    {
        'identifier': int,
        'token': int,
        'expires': int,
        '_all': int,
    },
    total=False,
)


VerificationTokenKeys = Literal[
    'identifier',
    'token',
    'expires',
]
VerificationTokenScalarFieldKeys = Literal[
    'identifier',
    'token',
    'expires',
]
VerificationTokenScalarFieldKeysT = TypeVar('VerificationTokenScalarFieldKeysT', bound=VerificationTokenScalarFieldKeys)

VerificationTokenRelationalFieldKeys = _NoneType

# Authenticator types

class AuthenticatorOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Authenticator create method"""
    userId: _str
    transports: Optional[_str]
    user: 'UserCreateNestedWithoutRelationsInput'


class AuthenticatorCreateInput(AuthenticatorOptionalCreateInput):
    """Required arguments to the Authenticator create method"""
    credentialID: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: _int
    credentialDeviceType: _str
    credentialBackedUp: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AuthenticatorOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Authenticator create method, without relations"""
    userId: _str
    transports: Optional[_str]


class AuthenticatorCreateWithoutRelationsInput(AuthenticatorOptionalCreateWithoutRelationsInput):
    """Required arguments to the Authenticator create method, without relations"""
    credentialID: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: _int
    credentialDeviceType: _str
    credentialBackedUp: _bool


class AuthenticatorCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AuthenticatorCreateWithoutRelationsInput'
    connect: 'AuthenticatorWhereUniqueInput'


class AuthenticatorCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AuthenticatorCreateWithoutRelationsInput', List['AuthenticatorCreateWithoutRelationsInput']]
    connect: Union['AuthenticatorWhereUniqueInput', List['AuthenticatorWhereUniqueInput']]


_AuthenticatorWhereUnique_credentialID_Input = TypedDict(
    '_AuthenticatorWhereUnique_credentialID_Input',
    {
        'credentialID': '_str',
    },
    total=True
)

_AuthenticatorCompoundPrimaryKeyInner = TypedDict(
    '_AuthenticatorCompoundPrimaryKeyInner',
    {
        'userId': '_str',
        'credentialID': '_str',
    },
    total=True
)

_AuthenticatorCompoundPrimaryKey = TypedDict(
    '_AuthenticatorCompoundPrimaryKey',
    {
        'userId_credentialID': '_AuthenticatorCompoundPrimaryKeyInner',
    },
    total=True
)

AuthenticatorWhereUniqueInput = Union[
    '_AuthenticatorWhereUnique_credentialID_Input',
    '_AuthenticatorCompoundPrimaryKey',
]


class AuthenticatorUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    credentialID: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: Union[AtomicIntInput, _int]
    credentialDeviceType: _str
    credentialBackedUp: _bool
    transports: Optional[_str]
    user: 'UserUpdateOneWithoutRelationsInput'


class AuthenticatorUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    credentialID: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: Union[AtomicIntInput, _int]
    credentialDeviceType: _str
    credentialBackedUp: _bool
    transports: Optional[_str]


class AuthenticatorUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AuthenticatorCreateWithoutRelationsInput']
    connect: List['AuthenticatorWhereUniqueInput']
    set: List['AuthenticatorWhereUniqueInput']
    disconnect: List['AuthenticatorWhereUniqueInput']
    delete: List['AuthenticatorWhereUniqueInput']

    # TODO
    # update: List['AuthenticatorUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AuthenticatorUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AuthenticatorScalarWhereInput']
    # upsert: List['AuthenticatorUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['AuthenticatorCreateOrConnectWithoutRelationsInput']


class AuthenticatorUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AuthenticatorCreateWithoutRelationsInput'
    connect: 'AuthenticatorWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AuthenticatorUpdateInput'
    # upsert: 'AuthenticatorUpsertWithoutRelationsInput'
    # connectOrCreate: 'AuthenticatorCreateOrConnectWithoutRelationsInput'


class AuthenticatorUpsertInput(TypedDict):
    create: 'AuthenticatorCreateInput'
    update: 'AuthenticatorUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Authenticator_credentialID_OrderByInput = TypedDict(
    '_Authenticator_credentialID_OrderByInput',
    {
        'credentialID': 'SortOrder',
    },
    total=True
)

_Authenticator_userId_OrderByInput = TypedDict(
    '_Authenticator_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Authenticator_providerAccountId_OrderByInput = TypedDict(
    '_Authenticator_providerAccountId_OrderByInput',
    {
        'providerAccountId': 'SortOrder',
    },
    total=True
)

_Authenticator_credentialPublicKey_OrderByInput = TypedDict(
    '_Authenticator_credentialPublicKey_OrderByInput',
    {
        'credentialPublicKey': 'SortOrder',
    },
    total=True
)

_Authenticator_counter_OrderByInput = TypedDict(
    '_Authenticator_counter_OrderByInput',
    {
        'counter': 'SortOrder',
    },
    total=True
)

_Authenticator_credentialDeviceType_OrderByInput = TypedDict(
    '_Authenticator_credentialDeviceType_OrderByInput',
    {
        'credentialDeviceType': 'SortOrder',
    },
    total=True
)

_Authenticator_credentialBackedUp_OrderByInput = TypedDict(
    '_Authenticator_credentialBackedUp_OrderByInput',
    {
        'credentialBackedUp': 'SortOrder',
    },
    total=True
)

_Authenticator_transports_OrderByInput = TypedDict(
    '_Authenticator_transports_OrderByInput',
    {
        'transports': 'SortOrder',
    },
    total=True
)

AuthenticatorOrderByInput = Union[
    '_Authenticator_credentialID_OrderByInput',
    '_Authenticator_userId_OrderByInput',
    '_Authenticator_providerAccountId_OrderByInput',
    '_Authenticator_credentialPublicKey_OrderByInput',
    '_Authenticator_counter_OrderByInput',
    '_Authenticator_credentialDeviceType_OrderByInput',
    '_Authenticator_credentialBackedUp_OrderByInput',
    '_Authenticator_transports_OrderByInput',
]



# recursive Authenticator types
# TODO: cleanup these types



AuthenticatorRelationFilter = TypedDict(
    'AuthenticatorRelationFilter',
    {
        'is': 'AuthenticatorWhereInput',
        'is_not': 'AuthenticatorWhereInput',
    },
    total=False,
)


class AuthenticatorListRelationFilter(TypedDict, total=False):
    some: 'AuthenticatorWhereInput'
    none: 'AuthenticatorWhereInput'
    every: 'AuthenticatorWhereInput'


class AuthenticatorInclude(TypedDict, total=False):
    """Authenticator relational arguments"""
    user: Union[bool, 'UserArgsFromAuthenticator']


class UserIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""
    accounts: Union[bool, 'FindManyAccountArgsFromAuthenticator']
    sessions: Union[bool, 'FindManySessionArgsFromAuthenticator']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromAuthenticator']
    configurations: Union[bool, 'FindManyConfigurationArgsFromAuthenticator']


class UserArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""
    user: Union[bool, 'UserArgsFromAuthenticator']


class AccountArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""
    user: Union[bool, 'UserArgsFromAuthenticator']


class SessionArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""


class VerificationTokenArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""
    user: Union[bool, 'UserArgsFromAuthenticator']


class AuthenticatorArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromAuthenticator(TypedDict, total=False):
    """Relational arguments for Authenticator"""
    user: Union[bool, 'UserArgsFromAuthenticator']


class ConfigurationArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromAuthenticator(TypedDict, total=False):
    """Arguments for Authenticator"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManyAuthenticatorArgs = FindManyAuthenticatorArgsFromAuthenticator
FindFirstAuthenticatorArgs = FindManyAuthenticatorArgsFromAuthenticator


class AuthenticatorWhereInput(TypedDict, total=False):
    """Authenticator arguments for searching"""
    credentialID: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    providerAccountId: Union[_str, 'types.StringFilter']
    credentialPublicKey: Union[_str, 'types.StringFilter']
    counter: Union[_int, 'types.IntFilter']
    credentialDeviceType: Union[_str, 'types.StringFilter']
    credentialBackedUp: Union[_bool, 'types.BooleanFilter']
    transports: Union[None, _str, 'types.StringFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['AuthenticatorWhereInput', List['AuthenticatorWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AuthenticatorWhereInput']
    OR: List['AuthenticatorWhereInput']
    NOT: List['AuthenticatorWhereInput']



# aggregate Authenticator types


class AuthenticatorScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Authenticator arguments for searching"""
    credentialID: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    providerAccountId: Union[_str, 'types.StringWithAggregatesFilter']
    credentialPublicKey: Union[_str, 'types.StringWithAggregatesFilter']
    counter: Union[_int, 'types.IntWithAggregatesFilter']
    credentialDeviceType: Union[_str, 'types.StringWithAggregatesFilter']
    credentialBackedUp: Union[_bool, 'types.BooleanWithAggregatesFilter']
    transports: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AuthenticatorScalarWhereWithAggregatesInput']
    OR: List['AuthenticatorScalarWhereWithAggregatesInput']
    NOT: List['AuthenticatorScalarWhereWithAggregatesInput']



class AuthenticatorGroupByOutput(TypedDict, total=False):
    credentialID: _str
    userId: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: _int
    credentialDeviceType: _str
    credentialBackedUp: _bool
    transports: _str
    _sum: 'AuthenticatorSumAggregateOutput'
    _avg: 'AuthenticatorAvgAggregateOutput'
    _min: 'AuthenticatorMinAggregateOutput'
    _max: 'AuthenticatorMaxAggregateOutput'
    _count: 'AuthenticatorCountAggregateOutput'


class AuthenticatorAvgAggregateOutput(TypedDict, total=False):
    """Authenticator output for aggregating averages"""
    counter: float


class AuthenticatorSumAggregateOutput(TypedDict, total=False):
    """Authenticator output for aggregating sums"""
    counter: _int


class AuthenticatorScalarAggregateOutput(TypedDict, total=False):
    """Authenticator output including scalar fields"""
    credentialID: _str
    userId: _str
    providerAccountId: _str
    credentialPublicKey: _str
    counter: _int
    credentialDeviceType: _str
    credentialBackedUp: _bool
    transports: _str


AuthenticatorMinAggregateOutput = AuthenticatorScalarAggregateOutput
AuthenticatorMaxAggregateOutput = AuthenticatorScalarAggregateOutput


class AuthenticatorMaxAggregateInput(TypedDict, total=False):
    """Authenticator input for aggregating by max"""
    credentialID: bool
    userId: bool
    providerAccountId: bool
    credentialPublicKey: bool
    counter: bool
    credentialDeviceType: bool
    credentialBackedUp: bool
    transports: bool


class AuthenticatorMinAggregateInput(TypedDict, total=False):
    """Authenticator input for aggregating by min"""
    credentialID: bool
    userId: bool
    providerAccountId: bool
    credentialPublicKey: bool
    counter: bool
    credentialDeviceType: bool
    credentialBackedUp: bool
    transports: bool


class AuthenticatorNumberAggregateInput(TypedDict, total=False):
    """Authenticator input for aggregating numbers"""
    counter: bool


AuthenticatorAvgAggregateInput = AuthenticatorNumberAggregateInput
AuthenticatorSumAggregateInput = AuthenticatorNumberAggregateInput


AuthenticatorCountAggregateInput = TypedDict(
    'AuthenticatorCountAggregateInput',
    {
        'credentialID': bool,
        'userId': bool,
        'providerAccountId': bool,
        'credentialPublicKey': bool,
        'counter': bool,
        'credentialDeviceType': bool,
        'credentialBackedUp': bool,
        'transports': bool,
        '_all': bool,
    },
    total=False,
)

AuthenticatorCountAggregateOutput = TypedDict(
    'AuthenticatorCountAggregateOutput',
    {
        'credentialID': int,
        'userId': int,
        'providerAccountId': int,
        'credentialPublicKey': int,
        'counter': int,
        'credentialDeviceType': int,
        'credentialBackedUp': int,
        'transports': int,
        '_all': int,
    },
    total=False,
)


AuthenticatorKeys = Literal[
    'credentialID',
    'userId',
    'providerAccountId',
    'credentialPublicKey',
    'counter',
    'credentialDeviceType',
    'credentialBackedUp',
    'transports',
    'user',
]
AuthenticatorScalarFieldKeys = Literal[
    'credentialID',
    'userId',
    'providerAccountId',
    'credentialPublicKey',
    'counter',
    'credentialDeviceType',
    'credentialBackedUp',
    'transports',
]
AuthenticatorScalarFieldKeysT = TypeVar('AuthenticatorScalarFieldKeysT', bound=AuthenticatorScalarFieldKeys)

AuthenticatorRelationalFieldKeys = Literal[
        'user',
    ]

# Configuration types

class ConfigurationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Configuration create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    generatedExcel: Optional['fields.Base64']
    generatedBulletins: Optional['fields.Base64']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ConfigurationCreateInput(ConfigurationOptionalCreateInput):
    """Required arguments to the Configuration create method"""
    fileName: _str
    excelUrl: _str
    wordUrl: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ConfigurationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Configuration create method, without relations"""
    id: _str
    userId: _str
    generatedExcel: Optional['fields.Base64']
    generatedBulletins: Optional['fields.Base64']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ConfigurationCreateWithoutRelationsInput(ConfigurationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Configuration create method, without relations"""
    fileName: _str
    excelUrl: _str
    wordUrl: _str


class ConfigurationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ConfigurationCreateWithoutRelationsInput'
    connect: 'ConfigurationWhereUniqueInput'


class ConfigurationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ConfigurationCreateWithoutRelationsInput', List['ConfigurationCreateWithoutRelationsInput']]
    connect: Union['ConfigurationWhereUniqueInput', List['ConfigurationWhereUniqueInput']]


_ConfigurationWhereUnique_id_Input = TypedDict(
    '_ConfigurationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ConfigurationWhereUniqueInput = _ConfigurationWhereUnique_id_Input


class ConfigurationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    fileName: _str
    excelUrl: _str
    wordUrl: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    generatedExcel: Optional['fields.Base64']
    generatedBulletins: Optional['fields.Base64']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ConfigurationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    fileName: _str
    excelUrl: _str
    wordUrl: _str
    generatedExcel: Optional['fields.Base64']
    generatedBulletins: Optional['fields.Base64']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ConfigurationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ConfigurationCreateWithoutRelationsInput']
    connect: List['ConfigurationWhereUniqueInput']
    set: List['ConfigurationWhereUniqueInput']
    disconnect: List['ConfigurationWhereUniqueInput']
    delete: List['ConfigurationWhereUniqueInput']

    # TODO
    # update: List['ConfigurationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ConfigurationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ConfigurationScalarWhereInput']
    # upsert: List['ConfigurationUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ConfigurationCreateOrConnectWithoutRelationsInput']


class ConfigurationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ConfigurationCreateWithoutRelationsInput'
    connect: 'ConfigurationWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ConfigurationUpdateInput'
    # upsert: 'ConfigurationUpsertWithoutRelationsInput'
    # connectOrCreate: 'ConfigurationCreateOrConnectWithoutRelationsInput'


class ConfigurationUpsertInput(TypedDict):
    create: 'ConfigurationCreateInput'
    update: 'ConfigurationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Configuration_id_OrderByInput = TypedDict(
    '_Configuration_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Configuration_fileName_OrderByInput = TypedDict(
    '_Configuration_fileName_OrderByInput',
    {
        'fileName': 'SortOrder',
    },
    total=True
)

_Configuration_excelUrl_OrderByInput = TypedDict(
    '_Configuration_excelUrl_OrderByInput',
    {
        'excelUrl': 'SortOrder',
    },
    total=True
)

_Configuration_wordUrl_OrderByInput = TypedDict(
    '_Configuration_wordUrl_OrderByInput',
    {
        'wordUrl': 'SortOrder',
    },
    total=True
)

_Configuration_userId_OrderByInput = TypedDict(
    '_Configuration_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Configuration_generatedExcel_OrderByInput = TypedDict(
    '_Configuration_generatedExcel_OrderByInput',
    {
        'generatedExcel': 'SortOrder',
    },
    total=True
)

_Configuration_generatedBulletins_OrderByInput = TypedDict(
    '_Configuration_generatedBulletins_OrderByInput',
    {
        'generatedBulletins': 'SortOrder',
    },
    total=True
)

_Configuration_createdAt_OrderByInput = TypedDict(
    '_Configuration_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Configuration_updatedAt_OrderByInput = TypedDict(
    '_Configuration_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ConfigurationOrderByInput = Union[
    '_Configuration_id_OrderByInput',
    '_Configuration_fileName_OrderByInput',
    '_Configuration_excelUrl_OrderByInput',
    '_Configuration_wordUrl_OrderByInput',
    '_Configuration_userId_OrderByInput',
    '_Configuration_generatedExcel_OrderByInput',
    '_Configuration_generatedBulletins_OrderByInput',
    '_Configuration_createdAt_OrderByInput',
    '_Configuration_updatedAt_OrderByInput',
]



# recursive Configuration types
# TODO: cleanup these types



ConfigurationRelationFilter = TypedDict(
    'ConfigurationRelationFilter',
    {
        'is': 'ConfigurationWhereInput',
        'is_not': 'ConfigurationWhereInput',
    },
    total=False,
)


class ConfigurationListRelationFilter(TypedDict, total=False):
    some: 'ConfigurationWhereInput'
    none: 'ConfigurationWhereInput'
    every: 'ConfigurationWhereInput'


class ConfigurationInclude(TypedDict, total=False):
    """Configuration relational arguments"""
    user: Union[bool, 'UserArgsFromConfiguration']


class UserIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""
    accounts: Union[bool, 'FindManyAccountArgsFromConfiguration']
    sessions: Union[bool, 'FindManySessionArgsFromConfiguration']
    Authenticator: Union[bool, 'FindManyAuthenticatorArgsFromConfiguration']
    configurations: Union[bool, 'FindManyConfigurationArgsFromConfiguration']


class UserArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class AccountIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""
    user: Union[bool, 'UserArgsFromConfiguration']


class AccountArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class SessionIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""
    user: Union[bool, 'UserArgsFromConfiguration']


class SessionArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'SessionIncludeFromSession'


class FindManySessionArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['SessionOrderByInput', List['SessionOrderByInput']]
    where: 'SessionWhereInput'
    cursor: 'SessionWhereUniqueInput'
    distinct: List['SessionScalarFieldKeys']
    include: 'SessionIncludeFromSession'


class VerificationTokenIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""


class VerificationTokenArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'VerificationTokenIncludeFromVerificationToken'


class FindManyVerificationTokenArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['VerificationTokenOrderByInput', List['VerificationTokenOrderByInput']]
    where: 'VerificationTokenWhereInput'
    cursor: 'VerificationTokenWhereUniqueInput'
    distinct: List['VerificationTokenScalarFieldKeys']
    include: 'VerificationTokenIncludeFromVerificationToken'


class AuthenticatorIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""
    user: Union[bool, 'UserArgsFromConfiguration']


class AuthenticatorArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'AuthenticatorIncludeFromAuthenticator'


class FindManyAuthenticatorArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['AuthenticatorOrderByInput', List['AuthenticatorOrderByInput']]
    where: 'AuthenticatorWhereInput'
    cursor: 'AuthenticatorWhereUniqueInput'
    distinct: List['AuthenticatorScalarFieldKeys']
    include: 'AuthenticatorIncludeFromAuthenticator'


class ConfigurationIncludeFromConfiguration(TypedDict, total=False):
    """Relational arguments for Configuration"""
    user: Union[bool, 'UserArgsFromConfiguration']


class ConfigurationArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    include: 'ConfigurationIncludeFromConfiguration'


class FindManyConfigurationArgsFromConfiguration(TypedDict, total=False):
    """Arguments for Configuration"""
    take: int
    skip: int
    order_by: Union['ConfigurationOrderByInput', List['ConfigurationOrderByInput']]
    where: 'ConfigurationWhereInput'
    cursor: 'ConfigurationWhereUniqueInput'
    distinct: List['ConfigurationScalarFieldKeys']
    include: 'ConfigurationIncludeFromConfiguration'




FindManyConfigurationArgs = FindManyConfigurationArgsFromConfiguration
FindFirstConfigurationArgs = FindManyConfigurationArgsFromConfiguration


class ConfigurationWhereInput(TypedDict, total=False):
    """Configuration arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    fileName: Union[_str, 'types.StringFilter']
    excelUrl: Union[_str, 'types.StringFilter']
    wordUrl: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    generatedExcel: Union[None, 'fields.Base64', 'types.BytesFilter']
    generatedBulletins: Union[None, 'fields.Base64', 'types.BytesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConfigurationWhereInput', List['ConfigurationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ConfigurationWhereInput']
    OR: List['ConfigurationWhereInput']
    NOT: List['ConfigurationWhereInput']



# aggregate Configuration types


class ConfigurationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Configuration arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    fileName: Union[_str, 'types.StringWithAggregatesFilter']
    excelUrl: Union[_str, 'types.StringWithAggregatesFilter']
    wordUrl: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    generatedExcel: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    generatedBulletins: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConfigurationScalarWhereWithAggregatesInput']
    OR: List['ConfigurationScalarWhereWithAggregatesInput']
    NOT: List['ConfigurationScalarWhereWithAggregatesInput']



class ConfigurationGroupByOutput(TypedDict, total=False):
    id: _str
    fileName: _str
    excelUrl: _str
    wordUrl: _str
    userId: _str
    generatedExcel: 'fields.Base64'
    generatedBulletins: 'fields.Base64'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ConfigurationSumAggregateOutput'
    _avg: 'ConfigurationAvgAggregateOutput'
    _min: 'ConfigurationMinAggregateOutput'
    _max: 'ConfigurationMaxAggregateOutput'
    _count: 'ConfigurationCountAggregateOutput'


class ConfigurationAvgAggregateOutput(TypedDict, total=False):
    """Configuration output for aggregating averages"""


class ConfigurationSumAggregateOutput(TypedDict, total=False):
    """Configuration output for aggregating sums"""


class ConfigurationScalarAggregateOutput(TypedDict, total=False):
    """Configuration output including scalar fields"""
    id: _str
    fileName: _str
    excelUrl: _str
    wordUrl: _str
    userId: _str
    generatedExcel: 'fields.Base64'
    generatedBulletins: 'fields.Base64'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ConfigurationMinAggregateOutput = ConfigurationScalarAggregateOutput
ConfigurationMaxAggregateOutput = ConfigurationScalarAggregateOutput


class ConfigurationMaxAggregateInput(TypedDict, total=False):
    """Configuration input for aggregating by max"""
    id: bool
    fileName: bool
    excelUrl: bool
    wordUrl: bool
    userId: bool
    generatedExcel: bool
    generatedBulletins: bool
    createdAt: bool
    updatedAt: bool


class ConfigurationMinAggregateInput(TypedDict, total=False):
    """Configuration input for aggregating by min"""
    id: bool
    fileName: bool
    excelUrl: bool
    wordUrl: bool
    userId: bool
    generatedExcel: bool
    generatedBulletins: bool
    createdAt: bool
    updatedAt: bool


class ConfigurationNumberAggregateInput(TypedDict, total=False):
    """Configuration input for aggregating numbers"""


ConfigurationAvgAggregateInput = ConfigurationNumberAggregateInput
ConfigurationSumAggregateInput = ConfigurationNumberAggregateInput


ConfigurationCountAggregateInput = TypedDict(
    'ConfigurationCountAggregateInput',
    {
        'id': bool,
        'fileName': bool,
        'excelUrl': bool,
        'wordUrl': bool,
        'userId': bool,
        'generatedExcel': bool,
        'generatedBulletins': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ConfigurationCountAggregateOutput = TypedDict(
    'ConfigurationCountAggregateOutput',
    {
        'id': int,
        'fileName': int,
        'excelUrl': int,
        'wordUrl': int,
        'userId': int,
        'generatedExcel': int,
        'generatedBulletins': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ConfigurationKeys = Literal[
    'id',
    'fileName',
    'excelUrl',
    'wordUrl',
    'userId',
    'user',
    'generatedExcel',
    'generatedBulletins',
    'createdAt',
    'updatedAt',
]
ConfigurationScalarFieldKeys = Literal[
    'id',
    'fileName',
    'excelUrl',
    'wordUrl',
    'userId',
    'generatedExcel',
    'generatedBulletins',
    'createdAt',
    'updatedAt',
]
ConfigurationScalarFieldKeysT = TypeVar('ConfigurationScalarFieldKeysT', bound=ConfigurationScalarFieldKeys)

ConfigurationRelationalFieldKeys = Literal[
        'user',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields